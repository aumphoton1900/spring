1)
In Spring Data, Page, Pageable, and PageRequest are interconnected components used for 
handling pagination and sorting in data access operations.

org.springframework.data.domain.Pageable:
This is an interface that represents the input parameters for a pagination request.
It defines methods to retrieve information about the desired page, such as:
getPageNumber(): The zero-based index of the page to retrieve.
getPageSize(): The maximum number of elements per page.
getSort(): The sorting criteria to apply (e.g., sort by a specific field in ascending or descending order).
Pageable objects are typically passed to repository methods (e.g., findAll(Pageable pageable)) 
to specify the desired pagination and sorting.

org.springframework.data.domain.PageRequest:
This is a concrete implementation of the Pageable interface.
It's a convenient class to create instances of Pageable.
You typically use static factory methods like PageRequest.of(int page, int size) or 
PageRequest.of(int page, int size, Sort sort) to construct PageRequest objects.

For example, PageRequest.of(0, 10) would create a Pageable object requesting the first page (index 0) with a size of 10 elements.

org.springframework.data.domain.Page:
This is an interface that represents a single page of data returned from a paginated query.

It extends Slice<T> and provides additional information beyond just the content of the current page.

Key methods include:

getContent(): Returns the List of elements on the current page.
getTotalPages(): The total number of pages available for the entire dataset.
getTotalElements(): The total number of elements in the entire dataset.
getNumber(): The current page number (zero-based).
getSize(): The maximum number of elements per page.
hasNext(), hasPrevious(), isFirst(), isLast(): Methods to check page navigation possibilities.
When you call a repository method that accepts a Pageable and returns a Page, 
Spring Data automatically populates the Page object with the relevant data and metadata.


In summary:
Pageable: defines what you want (page number, size, sort).
PageRequest: is how you create an instance of Pageable.
Page: is what you get back (the actual data for the requested page, plus metadata about the entire dataset).

2)
Spring Boot, especially with Spring Data JPA, offers robust and convenient mechanisms 
for implementing pagination and sorting in your applications. 
This allows you to efficiently handle large datasets by retrieving data in smaller, ordered chunks.

Key Components:
Pageable Interface: This interface defines the pagination information, 
including the page number (0-indexed) and the number of records per page (page size). 
It also incorporates sorting criteria.
PageRequest Class: A concrete implementation of Pageable, used to create Pageable objects with specific page number,
page size, and optional sorting.

Sort Class: Used to define sorting logic, specifying the property (field) to sort by 
and the sorting direction (ascending or descending).

PagingAndSortingRepository Interface: An extension of CrudRepository 
in Spring Data JPA that provides methods for performing pagination and sorting operations.

Page Object: The return type of paged queries, containing the requested page of data, 
along with metadata like total pages, total elements, and whether it's the first or last page.

Implementation Steps:
Create a Repository: Define a repository interface that extends PagingAndSortingRepository 
(or JpaRepository, which extends PagingAndSortingRepository).

Java

    public interface ProductRepository extends JpaRepository<Product, Long> {
        Page<Product> findByProductNameContaining(String name, Pageable pageable);
    }
    
Define a Service Method: In your service layer, create a method to retrieve paged and sorted data.


    import org.springframework.data.domain.Page;
    import org.springframework.data.domain.Pageable;
    import org.springframework.data.domain.PageRequest;
    import org.springframework.data.domain.Sort;

    @Service
    public class ProductService {

        @Autowired
        private ProductRepository productRepository;

        public Page<Product> getProducts(int page, int size, String sortBy, String sortDirection) {
            Sort sort = Sort.by(Sort.Direction.fromString(sortDirection), sortBy);
            Pageable pageable = PageRequest.of(page, size, sort);
            return productRepository.findAll(pageable);
        }
    }
    
Expose an Endpoint (Controller): Create a REST endpoint to accept pagination and sorting parameters from the client.


    @RestController
    @RequestMapping("/products")
    public class ProductController {

        @Autowired
        private ProductService productService;

        @GetMapping
        public Page<Product> getAllProducts(
                @RequestParam(defaultValue = "0") int page,
                @RequestParam(defaultValue = "10") int size,
                @RequestParam(defaultValue = "id") String sortBy,
                @RequestParam(defaultValue = "asc") String sortDirection) {
            return productService.getProducts(page, size, sortBy, sortDirection);
        }
    }
Example Usage:
A client could then make a request like:
Code

GET /products?page=1&size=5&sortBy=productName&sortDirection=desc
